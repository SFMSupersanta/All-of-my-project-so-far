<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC
    '-//W3C//DTD XHTML 1.0 Transitional//EN'
    'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'>
<html lang="en-us" xmlns='http://www.w3.org/1999/xhtml'>
<head>
	<title>Seneca | School of Computer Studies | Programming Fundamentals Using C</title>

	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	<meta http-equiv="PICS-Label" content='(PICS-1.1 "http://www.icra.org/ratingsv02.html" l gen true r (cz 1 lz 1 nz 1 oz 1 vz 1) "http://www.rsac.org/ratingsv01.html" l gen true r (n 0 s 0 v 0 l 0) "http://www.classify.org/safesurf/" l gen true r (SS~~000 1))' />

	<meta name="Copyright" content="(c) Copyright Seneca College 2004" />
	<meta name="Description" content="Welcome to the Bachelors Degree of Software Development Program Web Site.  On this site you can find the introductory programming course.  Designed by Chris Szalwinski." />
	<meta name="Abstract" content="This subject reviews the principles of procedural programming.  Students study the solution of problems using structured programming techniques with the C programming language.  The emphasis throughout is on the solution of small problems."/>
	<meta name="Author" content="chris.szalwinski@senecac.on.ca"/>
	<meta name="Keywords" content="sofware development, procedural programming, lecture notes"/>

	<link rel="stylesheet" type="text/css" href="style.043.css" tppabs="http://cs.senecac.on.ca/~btp100/pages/style.043.css">
	<link rel="stylesheet" type="text/css" href="styleSPrint.043.css" tppabs="http://cs.senecac.on.ca/~btp100/pages/styleSPrint.043.css" media="screen">
	<link rel="stylesheet" type="text/css" href="stylePPrint.043.css" tppabs="http://cs.senecac.on.ca/~btp100/pages/stylePPrint.043.css" media="print">
</head>

<body>

<table cellspacing="0" cellpadding="0">

	<!-- Body Cell -->
	<tr height="600">
		<!-- Content Area -->
		<td class="tbody" bgcolor="ffffff">
			<table cellpadding="10" width="100%">
				<tr>
					<td bgcolor="ffffff" valign="top">
					<br />
					<center><span class=texth>Module B - Computations</span>
					<br />
					<br />
					<span class=texthead>
					Variables</span><br />
					<br />
					<span class=textagend>
					Choose an appropriate data type for each variable in a program, based on
					knowledge of the features required of the variable and the internal
					representation of the available data type<br /><br />
					</span>
					<p class=quote>"For larger projects, strongly-typed languages are dramatically more productive, because many errors are caught at compile time rather than at run time (or worse, after your project has shipped)." (J Strout)</p>
					<span class=textagend>
					<a href="#typ">Data Types</a> |
					<a href="#exa">Integral Types</a> |
					<a href="#sci">Floating-Point Types</a> |
					<a href="#def">Declarations</a> |
					<a href="#exe">Exercises</a>
					</span>
					</center>
					<br />
					<br />
					<br />

					<p>
					A variable holds data that can change in value during the lifetime of the variable.&nbsp;
					The C language associates a data type with each variable.&nbsp;
					Each data type occupies a
					compiler-defined number of bytes.&nbsp;
					</p>
					<p align="center"><img src="data-types.gif" tppabs="http://cs.senecac.on.ca/~btp100/pages/images/data-types.gif" /></p>
					<p>
					Associating a data type with each variable imposes restrictions on the range of
					values that the variable may hold.&nbsp;
					</p>
					<br />

					<p id="typ" class="section">Primitive Data Types</p>
					<p>
					Typed languages, such as C, subdivide the universe of data values into
					sets of distinct type.&nbsp;
					A data type defines:
					<ul>
					<li>how the values are stored and </li>
					<li>how the operations on those values are performed.</li>
					</ul>
					C has four primitive data types:
					<ul>
					<li class="code">int</li>
					<li class="code">char</li>
					<li class="code">float</li>
					<li class="code">double</li>
					</ul>
					</p>
					<p>
					An <span class=code>int</span> occupies one word and can store an integer.&nbsp;
					On a 32-bit machine, an <span class=code>int</span> occupies 4 bytes:</p>
					<table align=center width="44%" cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td class=code colspan=32>int (32-bit machines)</td>
					<tr class=desc>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					</tr>
					<tr class=value>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					</tr>
					</table>
					<p>
					A <span class=code>char</span> occupies one byte and can
					store a character or a symbol:&nbsp;
					</p>
					<table align=center width="11%" cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td class=code colspan=8>char</td>
					<tr class=desc>
					<td colspan=8>1 Byte</td>
					</tr>
					<tr class=value>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					</tr>
					</table>
					<p>
					A <span class=code>float</span> typically occupies 4 bytes and can store
					a single-precision floating-point number:&nbsp;</p>
					<table align=center width="44%" cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td class=code colspan=32>float</td>
					<tr class=desc>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					</tr>
					<tr class=value>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					</tr>
					</table>
					<p>
					A <span class=code>double</span> typically occupies 8 bytes and can store
					a double-precision floating-point number:&nbsp;
					</p>
					<table align=center width="88%" cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td class=code colspan=64>double</td>
					<tr class=desc>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					</tr>
					<tr class=value>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					</tr>
					</table>

					<p class=ssection>Qualifiers</p>
					<p>
					We can qualify the <span class=code>int</span> data type so that it contains
					a minimum number of bits.&nbsp;
					The qualifiers are:</p>
					<ul>
					<li class=code>short</li>
					<li class=code>long</li>
					<li class=code>long long</li>
					</ul>
					<p>
					A <span class=code>short</span> contains at least 16 bits:</p>
					<table align=center width="22%" cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td class=code colspan=16>short</td>
					<tr class=desc>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					</tr>
					<tr class=value>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					</tr>
					</table>
					<p>
					A <span class=code>long</span> contains at least 32 bits:</p>
					<table align=center width="44%" cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td class=code colspan=32>long</td>
					<tr class=desc>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					</tr>
					<tr class=value>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					</tr>
					</table>
					<p>
					A <span class=code>long long</span> contains at least 64 bits:</p>
					<table align=center width="88%" cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td class=code colspan=64>long long</td>
					<tr class=desc>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					</tr>
					<tr class=value>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					</tr>
					</table>
					<p>
					We can also qualify the <span class=code>double</span>
					data type.&nbsp;
					A <span class=code>long double</span> typically
					occupies at least 64 bits:</p>
					<table align=center width="88%" cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td class=code colspan=64>long double</td>
					<tr class=desc>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					</tr>
					<tr class=value>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					</tr>
					</table>
					Standard C does not specify that a <span class=code>long double</span> must occupy a minimum number of bits, only that
					it occupies no less bits than a <span class=code>double</span>.&nbsp;
					<br />

					<p id="exa" class="section">Representation of Integral Values</p>
					<p>
					C stores integral values in equivalent binary form.
					</p>
					<p class="ssection">Non-Negative Values</p>
					<p>
					To convert a non-negative integer
					into its binary equivalent,
					we distinguish the component bits,
					focus on the lowest order
					bit as our first target, and then take the value
					<ul>
					<li>divide by 2,</li>
					<li>put the remainder into the target, </li>
					<li>make the next higher order bit the new target, and</li>
					<li>repeat this set of instructions</li>
					</ul></p>
					<p>
					Consider the number 92:
					<ul>
					<li>Identify the first target bit as bit 0</li>
					<li>Take 92, divide it by 2 and put the remainder (0) in bit 0
					<li>Take the result (46), divide it by 2 and put the remainder (0) in bit 1
					<li>Take the result (23), divide it by 2 and put the remainder (1) in bit 2
					<li>Take the result (11), divide it by 2 and put the remainder (1) in bit 3
					<li>Take the result (5), divide it by 2 and put the remainder (1) in bit 4
					<li>Take the result (2), divide it by 2 and put the remainder (0) in bit 5
					<li>Take the result (1), divide it by 2 and put the remainder (1) in bit 6
					<li>Take the result (0), divide it by 2 and put the remainder (0) in bit 7
					</ul>
					<table align=center cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td width="20%"><b>Bit # </b></td>
					<td width="10%">7</td><td width="10%">6</td><td width="10%">5</td><td width="10%">4</td><td width="10%">3</td><td width="10%">2</td><td width="10%">1</td><td width="10%">0</td>
					</tr>
					<tr class=value>
					<td><b>&nbsp;Value&nbsp;</b></td>
					<td>0</td><td>1</td><td>2</td><td>5</td><td>11</td><td>23</td><td>46</td><td>92</td>
					</tr>
					<tr class=addrec>
					<td><b>Bit Values</b></td>
					<td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td>
					</tr>
					</table>
					<p>
					(Right to left bit numbering is for illustrative purposes only.&nbsp;
					Intel machines use this little-endian ordering.&nbsp;
					Motorola machines use big-endian ordering - left
					to right.)
					</p>
					<p>
					To convert a binary number into its decimal
					equivalent, we multiply each bit value by its
					corresponding power of 2 and add the bit values
					together.</p>
					<p>
					Consider the 8-bit number 01011100<sub>2</sub>:</p>
					<table align=center cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td width="20%"><b>Bit # </b></td>
					<td width="10%">7</td><td width="10%">6</td><td width="10%">5</td><td width="10%">4</td><td width="10%">3</td><td width="10%">2</td><td width="10%">1</td><td width="10%">0</td>
					</tr>
					<tr class=desc>
					<td><b>Power of 2 </b></td>
					<td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td>
					</tr>
					<tr class=value>
					<td><b>Bit Values </b></td>
					<td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td>
					</tr>
					<tr class=desc>
					<td><b>Multiplier </b></td>
					<td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td>
					</tr>
					<tr class=addre>
					<td><b><center>Byte Value </center></b></td>
					<td colspan=8><center>&nbsp;0*128 + 1*64 + 0*32 + 1*16 + 1*8 + 1*4 + 0*2 + 0*1 = 92&nbsp;</center></td>
					</tr>
					</table>
					</p>
					<p>
					In-class practice: try exercise 1 on <a href="h3.html#ex1" tppabs="http://cs.senecac.on.ca/~btp100/pages/handouts/h3.html#ex1">handout 3</a>.&nbsp;
					</p>

					<p class="sssection">Negative and Positive Values</p>
					<p>
					Computers store negative integers using encoding schemes.&nbsp; The schemes
					available include:
					<ul>
					<li>two's complement notation,</li>
					<li>one's complement notation, and</li>
					<li>sign magnitude notation.</li>
					</ul>
					All of these schemes represent non-negative integers identically.&nbsp;
					The most popular scheme is two's complement.&nbsp;
					With two's complement notation, separate subtraction circuits in
					the ALU are unnecessary and there is only one representation of 0.&nbsp;
					</p>
					<p>
					To obtain the two's complement of an integer, we
					<ul>
					<li>flip the bits</li>
					<li>add one</li>
					</ul>
					For example,
					we represent the integer -92 by 10100100<sub>2</sub>
					</p>
					<table align=center cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td width="20%"><b>Bit # </b></td>
					<td width="10%">7</td><td width="10%">6</td><td width="10%">5</td><td width="10%">4</td><td width="10%">3</td><td width="10%">2</td><td width="10%">1</td><td width="10%">0</td>
					</tr>
					<tr class=value>
					<td><b>&nbsp;92&nbsp;=&gt;&nbsp;</b></td>
					<td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td>
					</tr>
					<tr class=value>
					<td><b>&nbsp;Flip&nbsp;Bits&nbsp;</b></td>
					<td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td>
					</tr>
					<tr class=value>
					<td><b>&nbsp;Add&nbsp;1&nbsp;</b></td>
					<td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td>
					</tr>
					<tr class=addrec>
					<td><b>&nbsp;-92&nbsp;=&gt;&nbsp;</b></td>
					<td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td>
					</tr>
					</table>
					<p>
					The range of values that an integral data type can hold depends upon the word size of the
					host machine and the encoding scheme for negative values.&nbsp; For a two's
					complement scheme on a 32-bit machine, the ranges are:</p>
					<table align=center cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td width="15%"><b>Type</b></td><td align=center width="15%"><b>Size</b></td><td align=center width="33%"><b>Min</b></td><td align=center width="32%"><b>Max</b></td></tr>
					<tr class=value>
					<td class=code>short</td><td align=center>&gt;=16 bits</td><td align=center>-32,768</td><td align=center>32,767</td></tr>
					<tr class=value>
					<td class=code>int</td><td align=center>1 word</td><td align=center>-2,147,483,648</td><td align=center>2,147,483,647</td></tr>
					<tr class=value>
					<td class=code>long</td><td align=center>&gt;=32 bits</td><td align=center>-2,147,483,648</td><td align=center>2,147,483,647</td></tr>
					<tr class=value>
					<td class=code>long long</td><td align=center>&gt;=64 bits</td><td align=center>&nbsp;-9,223,372,036,854,775,808&nbsp;</td><td align=center>&nbsp;9,223,372,036,854,775,807&nbsp;</td></tr>
					</table>
					<p>
					For a two's complement scheme on a 16-bit machine, the ranges are:</p>
					<table align=center cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td width="15%"><b>Type</b></td><td align=center width="15%"><b>Size</b></td><td align=center width="33%"><b>Min</b></td><td align=center width="32%"><b>Max</b></td></tr>
					<tr class=value>
					<td class=code>short</td><td align=center>&gt;=16 bits</td><td align=center>-32,768</td><td align=center>32,767</td></tr>
					<tr class=value>
					<td class=code>int</td><td align=center>1 word</td><td align=center>-32,768</td><td align=center>32,767</td></tr>
					<tr class=value>
					<td class=code>long</td><td align=center>&gt;=32 bits</td><td align=center>-2,147,483,648</td><td align=center>2,147,483,647</td></tr>
					<tr class=value>
					<td class=code>long long</td><td align=center>&gt;=64 bits</td><td align=center>&nbsp;-9,223,372,036,854,775,808&nbsp;</td><td align=center>&nbsp;9,223,372,036,854,775,807&nbsp;</td></tr>
					</table>
					<p>
					Note that only the limits on an <span class=code>int</span> vary from machine to machine,
					while the limits on a <span class=code>short</span>,
					<span class=code>long</span>, and <span class=code>long long</span>
					do not vary.
					</p>
					<p>
					In-class practice: try exercise 2 on <a href="h3.html#ex2" tppabs="http://cs.senecac.on.ca/~btp100/pages/handouts/h3.html#ex2">handout 3</a>.&nbsp;
					</p>

					<p class="sssection">Unsigned ints</p>
					<p>
					We can use all of the bits available to store the value of a
					variable if we know that the variable will always contain only
					non-negative integer values.&nbsp; In such cases, we add the qualifier
					<span class="code">unsigned</span>:
					<ul>
					<li class=code>unsigned short</li>
					<li class=code>unsigned int</li>
					<li class=code>unsigned long</li>
					<li class=code>unsigned long long</li>
					</ul>
					With unsigned variables, there is no need for a negative-value encoding scheme.&nbsp;
					</p>
					<p>
					The range that an <span class=code>unsigned</span> data type can hold depends
					only upon the word size of the host machine</p>
					<table align=center cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td width="25%"><b>Type</b></td><td align=center width="15%"><b>Size</b></td><td align=center width="10%"><b>Min</b></td><td align=center width="25%"><b>Max - 32 bit</b></td><td align=center width="25%"><b>Max - 16 bit</b></td></tr>
					<tr class=value>
					<td class=code>unsigned&nbsp;short</td><td align=center>&gt;=16 bits</td><td align=center>0</td><td colspan=2 align=center>65,535</td></tr>
					<tr class=value>
					<td class=code>unsigned&nbsp;int</td><td align=center>1 word</td><td align=center>0</td><td align=center>4,294,967,295</td><td align=center>65,535</td></tr>
					<tr class=value>
					<td class=code>unsigned&nbsp;long</td><td align=center>&gt;=32 bits</td><td align=center>0</td><td colspan=2 align=center>4,294,967,295</td></tr>
					<tr class=value>
					<td class=code>&nbsp;unsigned&nbsp;long&nbsp;long&nbsp;</td><td align=center>&gt;=64 bits</td><td align=center>0</td><td colspan=2 align=center>&nbsp;18,446,744,073,709,551,615&nbsp;</td></tr>
					</table>

					<p class="ssection">Cultural Symbols</p>
					<p>
					We store cultural symbols using an integral data type.
					</p>
					<p>
					Although cultural symbols have no intrinsic numerical representation,
					we associate each symbol with a unique integer.&nbsp;
					We call such associations encoding sequences.&nbsp;
					We store a symbol by storing the integer associated with the symbol.&nbsp;
					Encoding sequences predate modern computers.&nbsp; Consider for instance
					<a href="javascript:if(confirm('http://www.soton.ac.uk/~scp93ch/morse/index.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.soton.ac.uk/~scp93ch/morse/index.html'" tppabs="http://www.soton.ac.uk/~scp93ch/morse/index.html">Morse code</a>.&nbsp;
					</p>
					<p>
					To accommodate the various cultures throughout the world, we need
					a very broad symbol repertoire.&nbsp; Over 60 encoding sequences
					have already been defined.&nbsp;  They include</p>
					<table align=center cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td><b>&nbsp;&nbsp;Encoding Sequence&nbsp;&nbsp;</b></td><td><b>Full Name</b></td><td><b>&nbsp;# Bits&nbsp;</b></td><td><b>&nbsp;Defined In&nbsp;</b></td>
					</tr>
					<tr class=value>
					<td>UCS-4</td><td><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/ISO_10646  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/ISO_10646'" tppabs="http://en.wikipedia.org/wiki/ISO_10646">Universal Multiple-Octet Coded Character Set</a></td><td>32</td><td>1993</td>
					</tr>
					<tr class=value>
					<td>BMP</td><td>Basic Multilingual Plane</td><td>16</td><td>1993</td>
					</tr>
					<tr class=value>
					<td>Unicode</td><td>Unicode</td><td>16</td><td>1991</td>
					</tr>
					<tr class=value>
					<td>ASCII</td><td>&nbsp;American Standard Code for Information Interchange&nbsp;</td><td>7</td><td>1963</td>
					</tr>
					<tr class=value>
					<td>EBCDIC</td><td><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/EBCDIC  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/EBCDIC'" tppabs="http://en.wikipedia.org/wiki/EBCDIC">Extended Binary Coded Decimal Interchange Code</a></td><td>8</td><td>1963</td>
					</tr>
					</table>
					<p>
					UCS-4 is broad enough to represent all culture symbols throughout the world.&nbsp;
					BMP is sufficiently broad to represent the major cultural symbols including the 20,000
					or so Chinese-Japanese-Korean ideographs.&nbsp; Unicode (version 3.0) is fully
					compatible with BMP.&nbsp; ASCII is sufficiently broad to represent
					alphabetic symbols.&nbsp;
					ASCII is a subset of BMP and Unicode, which in turn
					are subsets of UCS-4.&nbsp; EBCDIC is an encoding sequence
					developed by IBM.</p>
					<p>
					The two popular encoding sequences are ASCII and EBCDIC.&nbsp;
					Both use a single byte.&nbsp;
					ASCII originates in paper tape and Morse code
					and is listed <a href="ascii.html" tppabs="http://cs.senecac.on.ca/~btp100/pages/resources/ascii.html">here</a>.&nbsp;
					ASCII represents the letter A by the bit pattern 01000001<sub>2</sub>
					or 0x41 or 65.&nbsp; EBCDIC originates in punched cards and is
					listed <a href="ebcdic.html" tppabs="http://cs.senecac.on.ca/~btp100/pages/resources/ebcdic.html">here</a>.&nbsp;
					EBCDIC represents the letter A by the bit pattern 11000001<sub>2</sub>
					or 0xC1 or 193.&nbsp; Note the different values for A under ASCII and EBCDIC.
					</p>
					<p>
					The EBCDIC symbol order differs from the ASCII symbol order.&nbsp; In ASCII, the
					digits precede the letters, while in EBCDIC, the letters precede the digits.&nbsp;
					If we use either sequence to sort symbolic information that contains digits
					and letters, we will obtain different results.&nbsp; <!--Click
					<a href="http://www.bobbemer.com/P-BIT.HTM">here</a> for the inside story
					on IBM's choice of EBCDIC.-->
					</p>
					<p>
					We use the ASCII encoding sequence throughout this course.&nbsp;
					</p>
					<p>
					In-class practice: try exercise 3 on <a href="h3.html#ex3" tppabs="http://cs.senecac.on.ca/~btp100/pages/handouts/h3.html#ex3">handout 3</a>.&nbsp;
					</p>
					<p>
					The range of values that a character data type can store varies from platform to platform.&nbsp;
					Compilers do not treat the <span class=code>char</span> data type consistently.&nbsp; Some
					treat it as <span class=code>signed</span>, while others treat it as <span class=code>unsigned</span>.&nbsp;
					For example, <span class=code>phobos</span> treats <span class=code>char</span>
					as <span class=code>unsigned</span>, while <span class=code>.net</span> treats
					<span class=code>char</span> as <span class=code>signed</span>.&nbsp;
					The ASCII sequence uses the common range [0,127] and we can expect the same results
					regardless of platform.
					</p>
					<table align=center cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td width="25%"><b>Type</b></td><td align=center width="25%"><b>Size</b></td><td align=center width="25%"><b>Min</b></td><td align=center width="25%"><b>Max</b></td></tr>
					<tr class=value>
					<td class=code>&nbsp;unsigned&nbsp;char&nbsp;</td><td align=center>1 byte</td><td align=center>0</td><td align=center>255</td></tr>
					<tr class=value>
					<td class=code>&nbsp;signed&nbsp;char&nbsp;</td><td align=center>1 byte</td><td align=center>-128</td><td align=center>127</td></tr>
					<tr class=value>
					<td class=code>char</td><td align=center>1 byte</td><td align=center>&lt;=0</td><td align=center>&gt;=127</td></tr>
					</table>

					<p id="sci" class="section">Representation of Floating-Point Data</p>
					<p>
					Computers store floating-point data using
					two separate components: an exponent and a mantissa.&nbsp;
					The models in use vary across implementations.&nbsp;
					C leaves the model open to definition.&nbsp; The most
					popular model is the IEEE (I-triple-E or
					Institute of Electrical and Electronics Engineers) Standard 754
					for Binary and Floating-Point Arithmetic.&nbsp;
					</p>
					<p>
					Under IEEE 754,
					the model for a <span class=code>float</span>
					occupies 32 bits, has one sign bit, a 23-bit mantissa and
					a 8-bit exponent:&nbsp;</p>
					<table align=center width="44%" cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td class=code colspan=32>float</td>
					<tr class=desc>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					<td colspan=8>1 Byte</td>
					</tr>
					<tr class=desc>
					<td colspan=1>s</td>
					<td colspan=7>exponent</td>
					<td colspan=24>mantissa</td>
					</tr>
					<tr class=value>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					</tr>
					</table>
					<p>
					We calculate the value using the formula
					<table width="45%">
					<tr>
					<td>
					<br />
					<pre>
 x = sign * 2<sup>exponent</sup> * { 1 + f<sub>1</sub>2<sup>-1</sup> + f<sub>2</sub>2<sup>-2</sup> + ... + f<sub>23</sub>2<sup>-23</sup>}</pre><br /></td></tr></table>
					where <span class=code>f<sub>i</sub></span> is the value of bit
					<span class=code>i</span> and
					<table width="45%">
					<tr>
					<td>
					<br />
					<pre>
 -126 &lt;= exponent &lt;= 127</pre><br /></td></tr></table>
					Under the IEEE standard,
					the model for a <span class=code>double</span>
					occupies 64 bits, has one sign bit, a 52-bit mantissa and
					a 11-bit exponent:&nbsp;
					</p>
					<table align=center width="88%" cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td class=code colspan=64>double</td>
					<tr class=desc>
					<td colspan=8 width="12%">1 Byte</td>
					<td colspan=8 width="12%">1 Byte</td>
					<td colspan=8 width="12%">1 Byte</td>
					<td colspan=8 width="12%">1 Byte</td>
					<td colspan=8 width="12%">1 Byte</td>
					<td colspan=8 width="12%">1 Byte</td>
					<td colspan=8 width="12%">1 Byte</td>
					<td colspan=8 width="12%">1 Byte</td>
					</tr>
					<tr class=desc>
					<td colspan=1>s</td>
					<td colspan=11>exponent</td>
					<td colspan=52>mantissa</td>
					</tr>
					<tr class=value>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					<td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td><td>&nbsp; </td>
					</tr>
					</table>
					<p>
					We calculate the value using the formula
					<table width="45%">
					<tr>
					<td>
					<br />
					<pre>
 x = sign * 2<sup>exponent</sup> * { 1 + f<sub>1</sub>2<sup>-1</sup> + f<sub>2</sub>2<sup>-2</sup> + ... + f<sub>52</sub>2<sup>-52</sup>}</pre><br /></td></tr></table>
					where <span class=code>f<sub>i</sub></span> is the value of bit
					<span class=code>i</span> and
					<table width="45%">
					<tr>
					<td>
					<br />
					<pre>
 -1022 &lt;= exponent &lt;= 1023</pre><br /></td></tr></table>
					The limits on
					<span class=code>float</span> and <span class=code>double</span> under the IEEE standard are:
					</p>
					<table width="90%" align=center cellspacing=1 cellpadding=1 border=1>
					<tr class=desc>
					<td width="15%"><b>Type</b></td><td align=center width="10%"><b>Size</b></td><td align=center width="15%"><b>Significant</b></td><td align=center width="15%"><b>Min Exponent</b></td><td align=center width="15%"><b>Max Exponent</b></td></tr>
					<tr class=value>
					<td class=code>float</td><td align=center>4 bytes</td><td align=center>6</td><td align=center>-37</td><td align=center>38</td></tr>
					<tr class=value>
					<td class=code>double</td><td align=center>8 bytes</td><td align=center>15</td><td align=center>-307</td><td align=center>308</td></tr>
					</table>
					<p>
					The exponent range values in this table are
					decimal (base 10).&nbsp;
					Note that both the number of significant digits
					and the range of the exponent are limited.&nbsp;
					</p>
					<br />

					<p id="def" class="section">Declarations</p>
					<p>
					We allocate memory for a variable by specifying its data type
					and optionally an initial value
					<pre class=defin>
 data_type identifier [= initial value];</pre>
					For example, to allocate memory for the variables <span class=code>section</span>,
					<span class=code>numberOfClasses</span> and <span class=code>cashFare</span>,
					and to initialize the <span class=code>cashFare</span> to 2.25, we assign
					the data types<span class=code>char</span>,
					<span class=code>int</span>, and <span class=code>double</span>
					respectively and write
					<table width="45%">
					<tr>
					<td>
					<br />
					<pre>
 char   section;
 int    numberOfClasses;
 double cashFare = 2.25;</pre><br /></td></tr></table>
					We conclude each declaration with a semi-colon.
					</p>
					<p>
					In allocating memory for variables of identical data type, we may
					group the identifiers in a single declaration and separate them with commas.&nbsp;
					For example,
					<table width="45%">
					<tr>
					<td>
					<br />
					<pre>
 char   section, letter, initial, answer;
 int    numberOfClasses, children, books, rooms;
 double cashFare, money, height, weight;</pre><br /></td></tr></table>
 					</p>
					<p class=ssection>Naming Conventions</p>
					<p>
					The identifiers that we use for variables must satisfy the following rules:
					<ul>
					<li>an identifier must start with a letter or underscore (_)</li>
					<li>an identifier may contain any combination of letters, digits and underscore (_)</li>
					<li>an identifier must not be a C reserved word</li>
					</ul>
					Some compilers allow more than 31 characters, while others do not.&nbsp;
					To be safe, we avoid using more than 31 characters.
					</p>
					<p>
					The C reserved words are
					<pre class=defin>
 auto       _Bool      break     case
 char       _Complex   const     continue
 default    restrict   do        double
 else       enum       extern    float
 for        goto       if        _Imaginary
 inline     int        long      register
 return     short      signed    sizeof
 static     struct     switch    typedef
 union      unsigned   void      volatile
 while</pre>
					</p>
					<p>
					For upward compatibility with C++, we also avoid using
					the C++ reserved words
					<pre class=defin>
 asm              export           private          throw
 bool             false            protected        true
 catch            friend           public           try
 class            mutable          reinterpret_cast typeid
 const_cast       namespace        static_cast      typename
 delete           new              template         using
 dynamic_cast     operator         this             virtual
 explicit                                           wchar_t</pre>
					</p>
					<p>
					In-class practice: try exercise 4 on <a href="h3.html#ex4" tppabs="http://cs.senecac.on.ca/~btp100/pages/handouts/h3.html#ex4">handout 3</a>.&nbsp;
					</p>
					<br />

					<p id="exe" class="section">Exercises</p>
					<p>
					<ul>
					<li>Study the ASCII table <a href="ascii.html" tppabs="http://cs.senecac.on.ca/~btp100/pages/resources/ascii.html">here</a></li>
					<li>Practice converting binary data to and from decimal representation</li>
					<li>Read pages 9-10, 13, 123-136, 141, 145 from Evan Weaver's subject notes.</li>
					<li>Pick ten different variables at random, select the data
					type that is most appropriate for each variable and write the
					C declarations for your set of variables.</li>
					</ul>
					</p>
					<br />
					<br />
					<br />
					</td>
				</tr>
			</table>
		</td>
	</tr>

	<!-- Footer -->
	<tr>
		<td class="tbody">
			<table cellpadding="1" width="90%" align="center">
				<tr>
					<td width="50%" class="text3">
						<script language="javascript">
						var lh = document.location.href;
						document.write(lh)
						</script>&nbsp;&nbsp;
					</td>
					<td width="50%" align="right" class="text3">
						<script language="javascript">
						var lm = document.lastModified.slice(0,-3);
						document.write("Last Modified: " +lm)
						</script>&nbsp;&nbsp;
					</td>
				</tr>
			</table>
		</td>
	</tr>
</table>

</body>
</html>